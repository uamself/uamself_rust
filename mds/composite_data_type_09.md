# 复合数据类型

## 数组（Array）

**数组是由相同类型的元素组合而成的复合类型。数组的长度是固定的，一旦声明，其长度不能增长或者缩小。**

### 数组声明

在Rust中数组的类型签名为：[T;N]。T表示数据类型，N表示数组的长度，编译时必须确定其大小。

数组有以下两种初始化方式：

1、中括号中列举所有的值，其中的值以英文逗号`，`隔开。示例代码如下：

```rust
    // 未声明类型
    let a = [1, 2, 3, 4, 5];
    // 声明类型
    let b: [i32; 5] = [1, 2, 3, 4, 5];
```

2、[2; 5]中括号中，第一个值表示默认初始元素，第二个值表示长度，中间使用英文分号`;`隔开。示例代码如下：

```rust
    // 未声明类型
    let c = [2; 5];
    // 声明类型
    let d: [i32; 5] = [2; 5];
```

上面的代码表示，初始化一个长度为5的数组，且每个元素的初始值指定为2。

### 数组访问

在Rust中可以通过“数组名称[索引]”来访问数组中响应位置的元素。索引值从0开始计数。示例代码如下：

```rust
  let e = [2, 4, 6, 8, 10];
    println!("数组e第三个位置的元素是 {}", e[2])
```

代码执行结果：

```
数组e第三个位置的元素是 6
```

### 数组越界

由于数组的长度是固定，如果访问时索引值超出数组的长度就会产生数组越界（Index Out Of Bounds）。数组的长度可以使用`len()`函数获取。下方的代码会输出长度为5：

```rust
    let f = [1, 3, 5, 7, 9];
    println!("f数组的长度是 {}", f.len());
    // 下面的代码会发生数据越界
    println!("{}", f[5]);
```

上面的代码执行`println!("{}", f[5]);`时会发生数组越界，报错信息如下。虽然说Rust的一门安全的语言，但是数据越界的问题还是无法避免的。

```rust
error: this operation will panic at runtime
 --> crates/basis/composite_data_type_09/src/main.rs:6:20
  |
6 |     println!("{}", f[5]);
  |                    ^^^^ index out of bounds: the length is 5 but the index is 5
  |
  = note: `#[deny(unconditional_panic)]` on by default

```

## 元组（Tuple）

元组是有一个或多个类型的元素组合而成的复合类型。官方没有给出明确定义。在使用过程中，元组通常至少包含两个元素。当然元组只包含一个元素也可以，没有元素也是可以的。

### 元组声明

元组是一种异构有限的序列。异构表示元组内的元素可以是不同类型的。有限是指元组的长度是固定的。元组的签名格式为：(T,U,M)，T，U，M均表示类型。示例代码如下：

```rust
    let tup: (i32, f64, bool) = (20, 3.14, false);  

    // 一个元素的元组
    let tup_single: (i32, ) = (5, );
    // 下面两种方式不是一个元组
    // 他们等价于 let tup_wrong = 5;
    // let tup_wrong = (5);
    // let tup_wrong: (i32) = (5);
    dbg!(tup_single);

    // 空元组
    let empty_tup = ();
    dbg!(empty_tup);
```

上面代码中，如果要声明只有一个元素的元组，则需要在元素后面加一个英文逗号。`let tup_wrong = (5)`这不是一个元组，相当于`let tup_wrong = 5`。空元组表示为`()`，不占任何内存空间，了解即可。

### 元组索引

元组默认是通过使用“元组名称.索引”来访问元组中相应位置的元素。示例代码如下：

```rust
let tup : (i32, f64, bool) = (20, 3.14, false);
println!("{} {} {} ", tup.0, tup.1, tup.2);
```

### 元组解构（Destructure）

元组是一个单独的复合元素，除了通过索引的方式去获取元组内的某个值，还可以使用模式匹配（Pattern Matching）的方式来解构（Destructure）元组。通常使用`let` + 模式来进行解构元组。示例代码如下：

```rust
    let tup : (i32, f64, bool) = (20, 3.14, false);
    let (x, y, z) = tup;
    println!("x: {}, y: {}, z: {}", x, y, z);
```

代码执行结果：

```
x: 20, y: 3.14, z: false
```

首先创建一个元组`tup`变量，然后使用`let`+模式将`tup`分为3个变量`x`，`y`，`z`。这个过程就叫做元组的解构（Destructure）。

PS：`let`除了可以绑定变量，还支持模式匹配。关于模式匹配将会在后续章节介绍。

## 小结

这节课了解了Rust的原始复合数据类型数组和元组。

这节课简单讲解了下数组，在下节课的“向量”讲解中还会进行一次详细的介绍。

可能你在浏览其它文章时发现复合数据类型还有结构体，枚举等等，后面会再详细介绍。

这节讲的数组和元组，以及之前讲的标量数据类型——整数型，浮点型，布尔型，字符型。这些数据类型的值都是直接保存在“栈”中。它们没有所有权的概念。

所有权是Rust的重要知识点之一。关于栈和所有权的知识也会在后续章节介绍。
