# 所有权

## 值语义（Value Semantics）

值语义，又叫值类型语义(**Value-Type Semantics**)或者按值复制语义(**Copy-By-Value Semantics**)。值语义是指按位复制后与原值无关，保证值的独立性，唯一性。在大部分语言中的基本数据类型都是值语义。按位复制就是**栈复制**。通俗一点讲，具有值语义的对象只能由赋值运算符修改。我们可以根据需要复制它，且任何副本都可以代替原始副本，而不会改变程序的行为。对于一个对象，只有对象的值是重要的，它的标识并不重要。

## 引用语义（Reference Semantics）

与值语义相对应的是引用语义。**引用语义**一般是指数据存储在堆内存中，通过栈内存里的指针来管理内存的数据。以 Rust 的向量为例，声明向量时，有一个区域是指向堆区的指针，而真正的数据则来自指针指向堆区的数据。可以按位复制（浅复制），但是按位复制会导致一个栈上会有多个指针指向堆上的同一区域，释放指针时容易造成堆上的数据二次释放。如果要复制引用语义上的数据通常是采用**深复制**，将栈上和堆上的数据同时复制。

## 所有权机制

上面两个语义，基本所有的语言都会存在。在此基础上，Rust 增加了另外两个语义—— **复制语义（Copy Semantics）**和**移动语义（Move Semantics）**。这算是 Rust 对值语义与引用语义的重新包装。**复制语义**对应值语义，**移动语义**对应引用语义。但是在所有权的机制下，又存在一些不同。

* 复制语义：可以在栈上进行**安全的**按位复制的类型。
* 移动语义：对于在堆上存储的数据，在栈上按位复制数据时，会导致多指针指向同一堆上的数据，容易引发内存问题。所以要解决这个问题，我们必须使用**深复制**。但是深复制时，需要开闭新的内存空间，又带了性能问题。所以我们可以保持堆上的数据不变，我们只需要移动指向堆内存的指针即可。

## 变量绑定与所有权

我们在声明变量时，使用的是 `let` 关键字，这里的**变量**，本质上是一种绑定关系。`let` 将一个变量和值绑定在一起，变量则对这个值拥有**所有权**。对值拥有所有权可能说的有点儿模糊，实际是应该说 `let` 的作用是**将变量与值的内存空间进行绑定，使得变量对值所在的内存空间拥有所有权**。这就会出现对于每一块内容空间都拥有为一个绑定变量与其对应，**非特殊场景下**不允许多个变量同时指向同一块内存空间。

PS：特殊场景指的是 `共享所有权`，后面的章节会讲到，请先忽略这个概念。

## 转移（Move）

在 Rust 中，在一些需要在堆上保存数据的类型来说，对于**变量之间赋值，向函数传值，从函数返回值**这些操作不会复制值，而是转移（move）值，将原来值所有者的所有权**让渡**给目标所有者。**对于原来的所有者将变成不可访问状态**。这也是 Rust 与其它语言的不同之处，如果你能理解 **move**，那表明你已经掌握了 Rust 三分之一的内容了。**所有权机制仅仅是针对在堆上分配数据的类型**。案例看主函数.

## 转移与流程控制

### 条件语句

```rust
fn print_dance(name: String) {
    println!("{} 喜欢跳舞", name);
}

fn print_swim(name: String) {
    println!("{} 喜欢游泳", name);
}

fn main() {
    let x = 3 % 2;
    let name = String::from("小明");
    if x == 0 {
        print_dance(name)
    } else {
        print_swim(name)
    }
    // 无法再次使用 name
    // print_dance(name);
  
    // 运行结果
    // 小明 喜欢游泳
}
```

### 循环语句

由于循环体的特殊性，当第二次运行循环体时，上一次循环已经发生转移。所以下面的代码将会编译错误。

```rust
fn main() {
    let name = String::from("rust");
    for _ in 1..4 {
        // 下面的代码 是错误的
        // print_dance(name);
    }
}
```

### 模式匹配

```rust
fn main() {
    // 【匹配】
    let x = 3 % 2;
    let name = String::from("小明");
    match x {
        0 => {
            print_dance(name);
        }
        1 => {
            print_swim(name);
        }
        _ => {
            println!("{}", name);
        }
    };
    // 下面的代码 是错误的
    // println!("{}", name);
  
    // 运行结果
    // 小明 喜欢游泳
}
```

## 共享所有权

所有权的概念非常苛刻，要求每个值有且仅有一个所有者。但是 Rust 也提供了相应的解决方法——共享所有权.

共享所有权的原理同样是引用计数。

Rust 提供了 **Rc** (Reference Count) 和 **Arc** (Atomic Reference Count) 两种类型来实现引用计数。

**Rc** 与 **Arc** 的用法完全相同，仅仅是应用场景不同，**Arc** 可以在线程中安全共享，**Rc** 则并不关注线程安全。接下来的演示我将仅以 **Rc** 为例。


使用 Rc 可以让一个值拥有多个所有者，每当值增加一个所有者，引用计数就会增加 1。当引用计数为 0 时，变量的内存将会被释放。

Rc 的使用还是很简单的，下面来看下代码吧。

```rust
use std::rc::Rc;


fn main() {
    // 创建一个字符串 rust
    let a: Rc<String> = Rc::new(String::from("rust"));
    // 调用 clone 方法，使指向字符串的引用计数 +1
    let b = a.clone();
    // Rc::clone(&a) 等价于 a.clone()
    let c = Rc::clone(&a);


    // 输出3个变量指向字符串的地址
    println!("{:p}", a.as_ptr());
    println!("{:p}", b.as_ptr());
    println!("{:p}", c.as_ptr());


    // 查看引用计数
    println!("引用计数 {} ", Rc::strong_count(&a));
    // 下面的代码只做了解
    println!("弱引用计数 {} ", Rc::weak_count(&a));
}


// 运行结果
// a 的地址: 0x28f97c2ac10
// b 的地址: 0x28f97c2ac10
// c 的地址: 0x28f97c2ac10
// 引用计数 3 
// 弱引用计数 0
```

我们先创建一个拥有共享所有权的字符串 `a = "rust"` , 使用克隆方法克隆 `a` 并与 `b` 和 `c` 变量绑定，`Rc::clone` 和 `clone` 方法是等价的，使用哪个都可以。最后输出 3 个变量字符串的地址。以及 `a` 的引用计数。从结果中可以看到地址都是一样的。并且我们还可以直接使用变量 `a` 来调用 `String` 的方法（下面是示例代码）。

```rust
use std::rc::Rc;


fn main() {
    // 创建一个字符串 rust
    let a: Rc<String> = Rc::new(String::from("rust"));
  
    // 使用 String 中的方法。
    if a.contains("ru") {
        println!("true");
    }
}
// 运行结果
// true
```

其实 `Rc<T>`持有一个指针（接下来的文章会介绍），指向堆空间的 `T` 值，同时该值还会有一个引用计数。使用 `clone` 方法只会增加引用计数，并不会复制值。**但是使用 Rc 指针引用的值不能被修改。**

## 小结

有关 Rust 转移的特性基本已经介绍完了。我相信读完文章的你没有感觉到它有多难，只是觉得这样的设计很新奇。总结下 Rust 所有权的几个核心特点吧：

* 所有权机制**仅针对在堆上分配的数据**，不包含基本类型。
* 变量与值的关系是绑定关系，变量拥有值的**所有权**。反过来讲。每一个值都存在一个**所有者**。**每块内存空间都存在一个所有者**。
* 当某一个变量离开当前所属的作用域后，变量将变为无效。
* 转移通常发生在变量间的赋值、向函数传值、从函数返回值这三大场景。
* 从目前来讲，所有的值有且只有一个所有者。
